// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: public/markets/market.proto

package ProtobufMarkets

/*
	NOTE: While a lot of these types have been expanded to indices, to prevent
	breaking clients by changing protbuf message types and names
	we'll just leave the package as ProtobufMarkets
*/

import (
	fmt "fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Trade_OrderSide int32

const (
	Trade_UNKNOWN  Trade_OrderSide = 0
	Trade_BUYSIDE  Trade_OrderSide = 1
	Trade_SELLSIDE Trade_OrderSide = 2
)

var Trade_OrderSide_name = map[int32]string{
	0: "UNKNOWN",
	1: "BUYSIDE",
	2: "SELLSIDE",
}
var Trade_OrderSide_value = map[string]int32{
	"UNKNOWN":  0,
	"BUYSIDE":  1,
	"SELLSIDE": 2,
}

func (x Trade_OrderSide) String() string {
	return proto.EnumName(Trade_OrderSide_name, int32(x))
}
func (Trade_OrderSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{2, 0}
}

// Deprecated
// Enum definitions are properties on the top-level message, so
// BUY and SELL are actually reserved on Trade. We need to keep
// this definition around because there doens't seem to be a way to
// reserve/deprecate enum values
type Trade_Side int32 // Deprecated: Do not use.
const (
	Trade_BUY  Trade_Side = 0 // Deprecated: Do not use.
	Trade_SELL Trade_Side = 1 // Deprecated: Do not use.
)

var Trade_Side_name = map[int32]string{
	0: "BUY",
	1: "SELL",
}
var Trade_Side_value = map[string]int32{
	"BUY":  0,
	"SELL": 1,
}

func (x Trade_Side) String() string {
	return proto.EnumName(Trade_Side_name, int32(x))
}
func (Trade_Side) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{2, 1}
}

// Market represents a currency pair on a particular exchange.
type Market struct {
	// Prefer integer ids to string slugs (far fewer bytes)
	ExchangeId     uint64 `protobuf:"varint,3,opt,name=exchangeId,proto3" json:"exchangeId,omitempty"`
	CurrencyPairId uint64 `protobuf:"varint,4,opt,name=currencyPairId,proto3" json:"currencyPairId,omitempty"`
	// New IDs from SQL; TODO remove 1,2,3,4 when migrationt o 5,6 is complete
	MarketId uint64 `protobuf:"varint,5,opt,name=marketId,proto3" json:"marketId,omitempty"`
	// Deprecated
	Exchange             string   `protobuf:"bytes,1,opt,name=exchange,proto3" json:"exchange,omitempty"`
	CurrencyPair         string   `protobuf:"bytes,2,opt,name=currencyPair,proto3" json:"currencyPair,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Market) Reset()         { *m = Market{} }
func (m *Market) String() string { return proto.CompactTextString(m) }
func (*Market) ProtoMessage()    {}
func (*Market) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{0}
}
func (m *Market) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Market) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Market.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Market) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Market.Merge(dst, src)
}
func (m *Market) XXX_Size() int {
	return m.Size()
}
func (m *Market) XXX_DiscardUnknown() {
	xxx_messageInfo_Market.DiscardUnknown(m)
}

var xxx_messageInfo_Market proto.InternalMessageInfo

func (m *Market) GetExchangeId() uint64 {
	if m != nil {
		return m.ExchangeId
	}
	return 0
}

func (m *Market) GetCurrencyPairId() uint64 {
	if m != nil {
		return m.CurrencyPairId
	}
	return 0
}

func (m *Market) GetMarketId() uint64 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *Market) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *Market) GetCurrencyPair() string {
	if m != nil {
		return m.CurrencyPair
	}
	return ""
}

// Order represents an ask or a bid.
type Order struct {
	PriceStr             string   `protobuf:"bytes,3,opt,name=priceStr,proto3" json:"priceStr,omitempty"`
	AmountStr            string   `protobuf:"bytes,4,opt,name=amountStr,proto3" json:"amountStr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{1}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(dst, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func (m *Order) GetAmountStr() string {
	if m != nil {
		return m.AmountStr
	}
	return ""
}

// Trade is a single trade in TradesUpdate
type Trade struct {
	// Exchange-specific ID
	ExternalId           string          `protobuf:"bytes,11,opt,name=externalId,proto3" json:"externalId,omitempty"`
	Timestamp            int64           `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TimestampNano        int64           `protobuf:"varint,10,opt,name=timestampNano,proto3" json:"timestampNano,omitempty"`
	PriceStr             string          `protobuf:"bytes,8,opt,name=priceStr,proto3" json:"priceStr,omitempty"`
	AmountStr            string          `protobuf:"bytes,9,opt,name=amountStr,proto3" json:"amountStr,omitempty"`
	OrderSide            Trade_OrderSide `protobuf:"varint,13,opt,name=orderSide,proto3,enum=ProtobufMarkets.Trade_OrderSide" json:"orderSide,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{2}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(dst, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func (m *Trade) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Trade) GetTimestampNano() int64 {
	if m != nil {
		return m.TimestampNano
	}
	return 0
}

func (m *Trade) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func (m *Trade) GetAmountStr() string {
	if m != nil {
		return m.AmountStr
	}
	return ""
}

func (m *Trade) GetOrderSide() Trade_OrderSide {
	if m != nil {
		return m.OrderSide
	}
	return Trade_UNKNOWN
}

// MarketUpdateMessage is the primary message for market updates; it wraps all
// other more specific update types.
type MarketUpdateMessage struct {
	Market *Market `protobuf:"bytes,9,opt,name=market,proto3" json:"market,omitempty"`
	// Types that are valid to be assigned to Update:
	//	*MarketUpdateMessage_OrderBookUpdate
	//	*MarketUpdateMessage_OrderBookDeltaUpdate
	//	*MarketUpdateMessage_OrderBookSpreadUpdate
	//	*MarketUpdateMessage_OrderBookLiquidityUpdate
	//	*MarketUpdateMessage_TradesUpdate
	//	*MarketUpdateMessage_IntervalsUpdate
	//	*MarketUpdateMessage_SummaryUpdate
	//	*MarketUpdateMessage_SparklineUpdate
	Update               isMarketUpdateMessage_Update `protobuf_oneof:"Update"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *MarketUpdateMessage) Reset()         { *m = MarketUpdateMessage{} }
func (m *MarketUpdateMessage) String() string { return proto.CompactTextString(m) }
func (*MarketUpdateMessage) ProtoMessage()    {}
func (*MarketUpdateMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{3}
}
func (m *MarketUpdateMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketUpdateMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketUpdateMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarketUpdateMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketUpdateMessage.Merge(dst, src)
}
func (m *MarketUpdateMessage) XXX_Size() int {
	return m.Size()
}
func (m *MarketUpdateMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketUpdateMessage.DiscardUnknown(m)
}

var xxx_messageInfo_MarketUpdateMessage proto.InternalMessageInfo

type isMarketUpdateMessage_Update interface {
	isMarketUpdateMessage_Update()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MarketUpdateMessage_OrderBookUpdate struct {
	OrderBookUpdate *OrderBookUpdate `protobuf:"bytes,2,opt,name=orderBookUpdate,proto3,oneof"`
}
type MarketUpdateMessage_OrderBookDeltaUpdate struct {
	OrderBookDeltaUpdate *OrderBookDeltaUpdate `protobuf:"bytes,3,opt,name=orderBookDeltaUpdate,proto3,oneof"`
}
type MarketUpdateMessage_OrderBookSpreadUpdate struct {
	OrderBookSpreadUpdate *OrderBookSpreadUpdate `protobuf:"bytes,11,opt,name=orderBookSpreadUpdate,proto3,oneof"`
}
type MarketUpdateMessage_OrderBookLiquidityUpdate struct {
	OrderBookLiquidityUpdate *OrderBookLiquidityUpdate `protobuf:"bytes,12,opt,name=orderBookLiquidityUpdate,proto3,oneof"`
}
type MarketUpdateMessage_TradesUpdate struct {
	TradesUpdate *TradesUpdate `protobuf:"bytes,4,opt,name=tradesUpdate,proto3,oneof"`
}
type MarketUpdateMessage_IntervalsUpdate struct {
	IntervalsUpdate *IntervalsUpdate `protobuf:"bytes,5,opt,name=intervalsUpdate,proto3,oneof"`
}
type MarketUpdateMessage_SummaryUpdate struct {
	SummaryUpdate *SummaryUpdate `protobuf:"bytes,6,opt,name=summaryUpdate,proto3,oneof"`
}
type MarketUpdateMessage_SparklineUpdate struct {
	SparklineUpdate *SparklineUpdate `protobuf:"bytes,7,opt,name=sparklineUpdate,proto3,oneof"`
}

func (*MarketUpdateMessage_OrderBookUpdate) isMarketUpdateMessage_Update()          {}
func (*MarketUpdateMessage_OrderBookDeltaUpdate) isMarketUpdateMessage_Update()     {}
func (*MarketUpdateMessage_OrderBookSpreadUpdate) isMarketUpdateMessage_Update()    {}
func (*MarketUpdateMessage_OrderBookLiquidityUpdate) isMarketUpdateMessage_Update() {}
func (*MarketUpdateMessage_TradesUpdate) isMarketUpdateMessage_Update()             {}
func (*MarketUpdateMessage_IntervalsUpdate) isMarketUpdateMessage_Update()          {}
func (*MarketUpdateMessage_SummaryUpdate) isMarketUpdateMessage_Update()            {}
func (*MarketUpdateMessage_SparklineUpdate) isMarketUpdateMessage_Update()          {}

func (m *MarketUpdateMessage) GetUpdate() isMarketUpdateMessage_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *MarketUpdateMessage) GetMarket() *Market {
	if m != nil {
		return m.Market
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookUpdate() *OrderBookUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookUpdate); ok {
		return x.OrderBookUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookDeltaUpdate() *OrderBookDeltaUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookDeltaUpdate); ok {
		return x.OrderBookDeltaUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookSpreadUpdate() *OrderBookSpreadUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookSpreadUpdate); ok {
		return x.OrderBookSpreadUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookLiquidityUpdate() *OrderBookLiquidityUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookLiquidityUpdate); ok {
		return x.OrderBookLiquidityUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetTradesUpdate() *TradesUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_TradesUpdate); ok {
		return x.TradesUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetIntervalsUpdate() *IntervalsUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_IntervalsUpdate); ok {
		return x.IntervalsUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetSummaryUpdate() *SummaryUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_SummaryUpdate); ok {
		return x.SummaryUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetSparklineUpdate() *SparklineUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_SparklineUpdate); ok {
		return x.SparklineUpdate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MarketUpdateMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MarketUpdateMessage_OneofMarshaler, _MarketUpdateMessage_OneofUnmarshaler, _MarketUpdateMessage_OneofSizer, []interface{}{
		(*MarketUpdateMessage_OrderBookUpdate)(nil),
		(*MarketUpdateMessage_OrderBookDeltaUpdate)(nil),
		(*MarketUpdateMessage_OrderBookSpreadUpdate)(nil),
		(*MarketUpdateMessage_OrderBookLiquidityUpdate)(nil),
		(*MarketUpdateMessage_TradesUpdate)(nil),
		(*MarketUpdateMessage_IntervalsUpdate)(nil),
		(*MarketUpdateMessage_SummaryUpdate)(nil),
		(*MarketUpdateMessage_SparklineUpdate)(nil),
	}
}

func _MarketUpdateMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MarketUpdateMessage)
	// Update
	switch x := m.Update.(type) {
	case *MarketUpdateMessage_OrderBookUpdate:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_OrderBookDeltaUpdate:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookDeltaUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_OrderBookSpreadUpdate:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookSpreadUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_OrderBookLiquidityUpdate:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookLiquidityUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_TradesUpdate:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TradesUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_IntervalsUpdate:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IntervalsUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_SummaryUpdate:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SummaryUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_SparklineUpdate:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparklineUpdate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MarketUpdateMessage.Update has unexpected type %T", x)
	}
	return nil
}

func _MarketUpdateMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MarketUpdateMessage)
	switch tag {
	case 2: // Update.orderBookUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookUpdate{msg}
		return true, err
	case 3: // Update.orderBookDeltaUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookDeltaUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookDeltaUpdate{msg}
		return true, err
	case 11: // Update.orderBookSpreadUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookSpreadUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookSpreadUpdate{msg}
		return true, err
	case 12: // Update.orderBookLiquidityUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookLiquidityUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookLiquidityUpdate{msg}
		return true, err
	case 4: // Update.tradesUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TradesUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_TradesUpdate{msg}
		return true, err
	case 5: // Update.intervalsUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntervalsUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_IntervalsUpdate{msg}
		return true, err
	case 6: // Update.summaryUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SummaryUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_SummaryUpdate{msg}
		return true, err
	case 7: // Update.sparklineUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SparklineUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_SparklineUpdate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MarketUpdateMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MarketUpdateMessage)
	// Update
	switch x := m.Update.(type) {
	case *MarketUpdateMessage_OrderBookUpdate:
		s := proto.Size(x.OrderBookUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_OrderBookDeltaUpdate:
		s := proto.Size(x.OrderBookDeltaUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_OrderBookSpreadUpdate:
		s := proto.Size(x.OrderBookSpreadUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_OrderBookLiquidityUpdate:
		s := proto.Size(x.OrderBookLiquidityUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_TradesUpdate:
		s := proto.Size(x.TradesUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_IntervalsUpdate:
		s := proto.Size(x.IntervalsUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_SummaryUpdate:
		s := proto.Size(x.SummaryUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_SparklineUpdate:
		s := proto.Size(x.SparklineUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// OrderBookUpdate represents a snapshot of the order book: a set of asks and
// bids for the particular aggregation modulus.
type OrderBookUpdate struct {
	// Aggregation modulus is a value which all bids and asks in this particular
	// OrderBookUpdate are divisible by. E.g. could be 1 (no aggregation), 5, 10,
	// 50, 100, etc. Exact possible values are set for each market individually.
	AggregationModulusStr string   `protobuf:"bytes,4,opt,name=aggregationModulusStr,proto3" json:"aggregationModulusStr,omitempty"`
	SeqNum                int32    `protobuf:"varint,5,opt,name=seqNum,proto3" json:"seqNum,omitempty"`
	Bids                  []*Order `protobuf:"bytes,1,rep,name=bids,proto3" json:"bids,omitempty"`
	Asks                  []*Order `protobuf:"bytes,2,rep,name=asks,proto3" json:"asks,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *OrderBookUpdate) Reset()         { *m = OrderBookUpdate{} }
func (m *OrderBookUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderBookUpdate) ProtoMessage()    {}
func (*OrderBookUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{4}
}
func (m *OrderBookUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookUpdate.Merge(dst, src)
}
func (m *OrderBookUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookUpdate proto.InternalMessageInfo

func (m *OrderBookUpdate) GetAggregationModulusStr() string {
	if m != nil {
		return m.AggregationModulusStr
	}
	return ""
}

func (m *OrderBookUpdate) GetSeqNum() int32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *OrderBookUpdate) GetBids() []*Order {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *OrderBookUpdate) GetAsks() []*Order {
	if m != nil {
		return m.Asks
	}
	return nil
}

// OrderBookDeltaUpdate represents a delta which needs to be applied to the
// local order book.
type OrderBookDeltaUpdate struct {
	// Aggregation modulus is a value which all bids and asks in this particular
	// OrderBookUpdate are divisible by. E.g. could be 1 (no aggregation), 5, 10,
	// 50, 100, etc. Exact possible values are set for each market individually.
	AggregationModulusStr string `protobuf:"bytes,4,opt,name=aggregationModulusStr,proto3" json:"aggregationModulusStr,omitempty"`
	SeqNum                int32  `protobuf:"varint,5,opt,name=seqNum,proto3" json:"seqNum,omitempty"`
	// Deltas for bids
	Bids *OrderBookDeltaUpdate_OrderDeltas `protobuf:"bytes,1,opt,name=bids,proto3" json:"bids,omitempty"`
	// Deltas for asks
	Asks                 *OrderBookDeltaUpdate_OrderDeltas `protobuf:"bytes,2,opt,name=asks,proto3" json:"asks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *OrderBookDeltaUpdate) Reset()         { *m = OrderBookDeltaUpdate{} }
func (m *OrderBookDeltaUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderBookDeltaUpdate) ProtoMessage()    {}
func (*OrderBookDeltaUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{5}
}
func (m *OrderBookDeltaUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookDeltaUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookDeltaUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookDeltaUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookDeltaUpdate.Merge(dst, src)
}
func (m *OrderBookDeltaUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookDeltaUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookDeltaUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookDeltaUpdate proto.InternalMessageInfo

func (m *OrderBookDeltaUpdate) GetAggregationModulusStr() string {
	if m != nil {
		return m.AggregationModulusStr
	}
	return ""
}

func (m *OrderBookDeltaUpdate) GetSeqNum() int32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *OrderBookDeltaUpdate) GetBids() *OrderBookDeltaUpdate_OrderDeltas {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *OrderBookDeltaUpdate) GetAsks() *OrderBookDeltaUpdate_OrderDeltas {
	if m != nil {
		return m.Asks
	}
	return nil
}

type OrderBookDeltaUpdate_OrderDeltas struct {
	// Either add a new order at a particular price, or replace existing one
	// (with the new amount)
	Set []*Order `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty"`
	// TODO: I see we don't really use deltas, and just use set?
	Delta []*Order `protobuf:"bytes,2,rep,name=delta,proto3" json:"delta,omitempty"`
	// Remove order at a particular price
	RemoveStr            []string `protobuf:"bytes,4,rep,name=removeStr,proto3" json:"removeStr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderBookDeltaUpdate_OrderDeltas) Reset()         { *m = OrderBookDeltaUpdate_OrderDeltas{} }
func (m *OrderBookDeltaUpdate_OrderDeltas) String() string { return proto.CompactTextString(m) }
func (*OrderBookDeltaUpdate_OrderDeltas) ProtoMessage()    {}
func (*OrderBookDeltaUpdate_OrderDeltas) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{5, 0}
}
func (m *OrderBookDeltaUpdate_OrderDeltas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookDeltaUpdate_OrderDeltas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookDeltaUpdate_OrderDeltas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookDeltaUpdate_OrderDeltas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookDeltaUpdate_OrderDeltas.Merge(dst, src)
}
func (m *OrderBookDeltaUpdate_OrderDeltas) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookDeltaUpdate_OrderDeltas) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookDeltaUpdate_OrderDeltas.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookDeltaUpdate_OrderDeltas proto.InternalMessageInfo

func (m *OrderBookDeltaUpdate_OrderDeltas) GetSet() []*Order {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetDelta() []*Order {
	if m != nil {
		return m.Delta
	}
	return nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetRemoveStr() []string {
	if m != nil {
		return m.RemoveStr
	}
	return nil
}

// OrderBookSpreadUpdate represents only the best bid & ask
type OrderBookSpreadUpdate struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Bid                  *Order   `protobuf:"bytes,2,opt,name=bid,proto3" json:"bid,omitempty"`
	Ask                  *Order   `protobuf:"bytes,3,opt,name=ask,proto3" json:"ask,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderBookSpreadUpdate) Reset()         { *m = OrderBookSpreadUpdate{} }
func (m *OrderBookSpreadUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderBookSpreadUpdate) ProtoMessage()    {}
func (*OrderBookSpreadUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{6}
}
func (m *OrderBookSpreadUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookSpreadUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookSpreadUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookSpreadUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookSpreadUpdate.Merge(dst, src)
}
func (m *OrderBookSpreadUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookSpreadUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookSpreadUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookSpreadUpdate proto.InternalMessageInfo

func (m *OrderBookSpreadUpdate) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *OrderBookSpreadUpdate) GetBid() *Order {
	if m != nil {
		return m.Bid
	}
	return nil
}

func (m *OrderBookSpreadUpdate) GetAsk() *Order {
	if m != nil {
		return m.Ask
	}
	return nil
}

// OrderBookLiquidityUpdate represents sums for various bips in the book
type OrderBookLiquidityUpdate struct {
	Timestamp            int64                                                  `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Bid                  *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide `protobuf:"bytes,2,opt,name=bid,proto3" json:"bid,omitempty"`
	Ask                  *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide `protobuf:"bytes,3,opt,name=ask,proto3" json:"ask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *OrderBookLiquidityUpdate) Reset()         { *m = OrderBookLiquidityUpdate{} }
func (m *OrderBookLiquidityUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderBookLiquidityUpdate) ProtoMessage()    {}
func (*OrderBookLiquidityUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{7}
}
func (m *OrderBookLiquidityUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookLiquidityUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookLiquidityUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookLiquidityUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookLiquidityUpdate.Merge(dst, src)
}
func (m *OrderBookLiquidityUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookLiquidityUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookLiquidityUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookLiquidityUpdate proto.InternalMessageInfo

func (m *OrderBookLiquidityUpdate) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *OrderBookLiquidityUpdate) GetBid() *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide {
	if m != nil {
		return m.Bid
	}
	return nil
}

func (m *OrderBookLiquidityUpdate) GetAsk() *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide {
	if m != nil {
		return m.Ask
	}
	return nil
}

type OrderBookLiquidityUpdate_OrderBookLiquiditySums struct {
	TotalBase            string   `protobuf:"bytes,1,opt,name=totalBase,proto3" json:"totalBase,omitempty"`
	TotalQuote           string   `protobuf:"bytes,2,opt,name=totalQuote,proto3" json:"totalQuote,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) Reset() {
	*m = OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) String() string {
	return proto.CompactTextString(m)
}
func (*OrderBookLiquidityUpdate_OrderBookLiquiditySums) ProtoMessage() {}
func (*OrderBookLiquidityUpdate_OrderBookLiquiditySums) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{7, 0}
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookLiquidityUpdate_OrderBookLiquiditySums.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookLiquidityUpdate_OrderBookLiquiditySums) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookLiquidityUpdate_OrderBookLiquiditySums.Merge(dst, src)
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookLiquidityUpdate_OrderBookLiquiditySums.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookLiquidityUpdate_OrderBookLiquiditySums proto.InternalMessageInfo

func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) GetTotalBase() string {
	if m != nil {
		return m.TotalBase
	}
	return ""
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) GetTotalQuote() string {
	if m != nil {
		return m.TotalQuote
	}
	return ""
}

type OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide struct {
	Bip25                *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,1,opt,name=bip25,proto3" json:"bip25,omitempty"`
	Bip50                *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,2,opt,name=bip50,proto3" json:"bip50,omitempty"`
	Bip75                *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,3,opt,name=bip75,proto3" json:"bip75,omitempty"`
	Bip100               *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,4,opt,name=bip100,proto3" json:"bip100,omitempty"`
	Bip150               *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,5,opt,name=bip150,proto3" json:"bip150,omitempty"`
	Bip200               *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,6,opt,name=bip200,proto3" json:"bip200,omitempty"`
	Bip250               *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,7,opt,name=bip250,proto3" json:"bip250,omitempty"`
	Bip300               *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,8,opt,name=bip300,proto3" json:"bip300,omitempty"`
	Bip400               *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,9,opt,name=bip400,proto3" json:"bip400,omitempty"`
	Bip500               *OrderBookLiquidityUpdate_OrderBookLiquiditySums `protobuf:"bytes,10,opt,name=bip500,proto3" json:"bip500,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) Reset() {
	*m = OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide{}
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) String() string {
	return proto.CompactTextString(m)
}
func (*OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) ProtoMessage() {}
func (*OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{7, 1}
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide.Merge(dst, src)
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide proto.InternalMessageInfo

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip25() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip25
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip50() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip50
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip75() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip75
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip100() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip100
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip150() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip150
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip200() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip200
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip250() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip250
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip300() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip300
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip400() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip400
	}
	return nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) GetBip500() *OrderBookLiquidityUpdate_OrderBookLiquiditySums {
	if m != nil {
		return m.Bip500
	}
	return nil
}

// TradesUpdate represents a set of new trades.
type TradesUpdate struct {
	Trades               []*Trade `protobuf:"bytes,1,rep,name=trades,proto3" json:"trades,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TradesUpdate) Reset()         { *m = TradesUpdate{} }
func (m *TradesUpdate) String() string { return proto.CompactTextString(m) }
func (*TradesUpdate) ProtoMessage()    {}
func (*TradesUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{8}
}
func (m *TradesUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradesUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradesUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TradesUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradesUpdate.Merge(dst, src)
}
func (m *TradesUpdate) XXX_Size() int {
	return m.Size()
}
func (m *TradesUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_TradesUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_TradesUpdate proto.InternalMessageInfo

func (m *TradesUpdate) GetTrades() []*Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

// Interval represents a single OHLC candle.
type Interval struct {
	Closetime            int64          `protobuf:"varint,1,opt,name=closetime,proto3" json:"closetime,omitempty"`
	Ohlc                 *Interval_OHLC `protobuf:"bytes,2,opt,name=ohlc,proto3" json:"ohlc,omitempty"`
	VolumeBaseStr        string         `protobuf:"bytes,6,opt,name=volumeBaseStr,proto3" json:"volumeBaseStr,omitempty"`
	VolumeQuoteStr       string         `protobuf:"bytes,7,opt,name=volumeQuoteStr,proto3" json:"volumeQuoteStr,omitempty"`
	PeriodName           string         `protobuf:"bytes,9,opt,name=periodName,proto3" json:"periodName,omitempty"`
	Period               int32          `protobuf:"varint,4,opt,name=period,proto3" json:"period,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Interval) Reset()         { *m = Interval{} }
func (m *Interval) String() string { return proto.CompactTextString(m) }
func (*Interval) ProtoMessage()    {}
func (*Interval) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{9}
}
func (m *Interval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Interval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Interval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interval.Merge(dst, src)
}
func (m *Interval) XXX_Size() int {
	return m.Size()
}
func (m *Interval) XXX_DiscardUnknown() {
	xxx_messageInfo_Interval.DiscardUnknown(m)
}

var xxx_messageInfo_Interval proto.InternalMessageInfo

func (m *Interval) GetClosetime() int64 {
	if m != nil {
		return m.Closetime
	}
	return 0
}

func (m *Interval) GetOhlc() *Interval_OHLC {
	if m != nil {
		return m.Ohlc
	}
	return nil
}

func (m *Interval) GetVolumeBaseStr() string {
	if m != nil {
		return m.VolumeBaseStr
	}
	return ""
}

func (m *Interval) GetVolumeQuoteStr() string {
	if m != nil {
		return m.VolumeQuoteStr
	}
	return ""
}

func (m *Interval) GetPeriodName() string {
	if m != nil {
		return m.PeriodName
	}
	return ""
}

func (m *Interval) GetPeriod() int32 {
	if m != nil {
		return m.Period
	}
	return 0
}

type Interval_OHLC struct {
	OpenStr              string   `protobuf:"bytes,5,opt,name=openStr,proto3" json:"openStr,omitempty"`
	HighStr              string   `protobuf:"bytes,6,opt,name=highStr,proto3" json:"highStr,omitempty"`
	LowStr               string   `protobuf:"bytes,7,opt,name=lowStr,proto3" json:"lowStr,omitempty"`
	CloseStr             string   `protobuf:"bytes,8,opt,name=closeStr,proto3" json:"closeStr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Interval_OHLC) Reset()         { *m = Interval_OHLC{} }
func (m *Interval_OHLC) String() string { return proto.CompactTextString(m) }
func (*Interval_OHLC) ProtoMessage()    {}
func (*Interval_OHLC) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{9, 0}
}
func (m *Interval_OHLC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interval_OHLC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Interval_OHLC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Interval_OHLC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interval_OHLC.Merge(dst, src)
}
func (m *Interval_OHLC) XXX_Size() int {
	return m.Size()
}
func (m *Interval_OHLC) XXX_DiscardUnknown() {
	xxx_messageInfo_Interval_OHLC.DiscardUnknown(m)
}

var xxx_messageInfo_Interval_OHLC proto.InternalMessageInfo

func (m *Interval_OHLC) GetOpenStr() string {
	if m != nil {
		return m.OpenStr
	}
	return ""
}

func (m *Interval_OHLC) GetHighStr() string {
	if m != nil {
		return m.HighStr
	}
	return ""
}

func (m *Interval_OHLC) GetLowStr() string {
	if m != nil {
		return m.LowStr
	}
	return ""
}

func (m *Interval_OHLC) GetCloseStr() string {
	if m != nil {
		return m.CloseStr
	}
	return ""
}

// IntervalsUpdate represents a set of new Intervals (OHLC candles)
type IntervalsUpdate struct {
	Intervals            []*Interval `protobuf:"bytes,1,rep,name=intervals,proto3" json:"intervals,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *IntervalsUpdate) Reset()         { *m = IntervalsUpdate{} }
func (m *IntervalsUpdate) String() string { return proto.CompactTextString(m) }
func (*IntervalsUpdate) ProtoMessage()    {}
func (*IntervalsUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{10}
}
func (m *IntervalsUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntervalsUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntervalsUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IntervalsUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntervalsUpdate.Merge(dst, src)
}
func (m *IntervalsUpdate) XXX_Size() int {
	return m.Size()
}
func (m *IntervalsUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_IntervalsUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_IntervalsUpdate proto.InternalMessageInfo

func (m *IntervalsUpdate) GetIntervals() []*Interval {
	if m != nil {
		return m.Intervals
	}
	return nil
}

// SummaryUpdate is a market summary update
type SummaryUpdate struct {
	LastStr              string   `protobuf:"bytes,10,opt,name=lastStr,proto3" json:"lastStr,omitempty"`
	HighStr              string   `protobuf:"bytes,11,opt,name=highStr,proto3" json:"highStr,omitempty"`
	LowStr               string   `protobuf:"bytes,12,opt,name=lowStr,proto3" json:"lowStr,omitempty"`
	VolumeBaseStr        string   `protobuf:"bytes,13,opt,name=volumeBaseStr,proto3" json:"volumeBaseStr,omitempty"`
	VolumeQuoteStr       string   `protobuf:"bytes,14,opt,name=volumeQuoteStr,proto3" json:"volumeQuoteStr,omitempty"`
	ChangeAbsoluteStr    string   `protobuf:"bytes,15,opt,name=changeAbsoluteStr,proto3" json:"changeAbsoluteStr,omitempty"`
	ChangePercentStr     string   `protobuf:"bytes,16,opt,name=changePercentStr,proto3" json:"changePercentStr,omitempty"`
	NumTrades            int32    `protobuf:"varint,8,opt,name=numTrades,proto3" json:"numTrades,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SummaryUpdate) Reset()         { *m = SummaryUpdate{} }
func (m *SummaryUpdate) String() string { return proto.CompactTextString(m) }
func (*SummaryUpdate) ProtoMessage()    {}
func (*SummaryUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{11}
}
func (m *SummaryUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SummaryUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SummaryUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SummaryUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SummaryUpdate.Merge(dst, src)
}
func (m *SummaryUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SummaryUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SummaryUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SummaryUpdate proto.InternalMessageInfo

func (m *SummaryUpdate) GetLastStr() string {
	if m != nil {
		return m.LastStr
	}
	return ""
}

func (m *SummaryUpdate) GetHighStr() string {
	if m != nil {
		return m.HighStr
	}
	return ""
}

func (m *SummaryUpdate) GetLowStr() string {
	if m != nil {
		return m.LowStr
	}
	return ""
}

func (m *SummaryUpdate) GetVolumeBaseStr() string {
	if m != nil {
		return m.VolumeBaseStr
	}
	return ""
}

func (m *SummaryUpdate) GetVolumeQuoteStr() string {
	if m != nil {
		return m.VolumeQuoteStr
	}
	return ""
}

func (m *SummaryUpdate) GetChangeAbsoluteStr() string {
	if m != nil {
		return m.ChangeAbsoluteStr
	}
	return ""
}

func (m *SummaryUpdate) GetChangePercentStr() string {
	if m != nil {
		return m.ChangePercentStr
	}
	return ""
}

func (m *SummaryUpdate) GetNumTrades() int32 {
	if m != nil {
		return m.NumTrades
	}
	return 0
}

type SparklineUpdate struct {
	Time                 int64    `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	PriceStr             string   `protobuf:"bytes,4,opt,name=priceStr,proto3" json:"priceStr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SparklineUpdate) Reset()         { *m = SparklineUpdate{} }
func (m *SparklineUpdate) String() string { return proto.CompactTextString(m) }
func (*SparklineUpdate) ProtoMessage()    {}
func (*SparklineUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_market_4eb507ded1b31144, []int{12}
}
func (m *SparklineUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparklineUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparklineUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SparklineUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparklineUpdate.Merge(dst, src)
}
func (m *SparklineUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SparklineUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SparklineUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SparklineUpdate proto.InternalMessageInfo

func (m *SparklineUpdate) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SparklineUpdate) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func init() {
	proto.RegisterType((*Market)(nil), "ProtobufMarkets.Market")
	proto.RegisterType((*Order)(nil), "ProtobufMarkets.Order")
	proto.RegisterType((*Trade)(nil), "ProtobufMarkets.Trade")
	proto.RegisterType((*MarketUpdateMessage)(nil), "ProtobufMarkets.MarketUpdateMessage")
	proto.RegisterType((*OrderBookUpdate)(nil), "ProtobufMarkets.OrderBookUpdate")
	proto.RegisterType((*OrderBookDeltaUpdate)(nil), "ProtobufMarkets.OrderBookDeltaUpdate")
	proto.RegisterType((*OrderBookDeltaUpdate_OrderDeltas)(nil), "ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas")
	proto.RegisterType((*OrderBookSpreadUpdate)(nil), "ProtobufMarkets.OrderBookSpreadUpdate")
	proto.RegisterType((*OrderBookLiquidityUpdate)(nil), "ProtobufMarkets.OrderBookLiquidityUpdate")
	proto.RegisterType((*OrderBookLiquidityUpdate_OrderBookLiquiditySums)(nil), "ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquiditySums")
	proto.RegisterType((*OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide)(nil), "ProtobufMarkets.OrderBookLiquidityUpdate.OrderBookLiquidityUpdateSide")
	proto.RegisterType((*TradesUpdate)(nil), "ProtobufMarkets.TradesUpdate")
	proto.RegisterType((*Interval)(nil), "ProtobufMarkets.Interval")
	proto.RegisterType((*Interval_OHLC)(nil), "ProtobufMarkets.Interval.OHLC")
	proto.RegisterType((*IntervalsUpdate)(nil), "ProtobufMarkets.IntervalsUpdate")
	proto.RegisterType((*SummaryUpdate)(nil), "ProtobufMarkets.SummaryUpdate")
	proto.RegisterType((*SparklineUpdate)(nil), "ProtobufMarkets.SparklineUpdate")
	proto.RegisterEnum("ProtobufMarkets.Trade_OrderSide", Trade_OrderSide_name, Trade_OrderSide_value)
	proto.RegisterEnum("ProtobufMarkets.Trade_Side", Trade_Side_name, Trade_Side_value)
}
func (m *Market) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Market) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Exchange) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.Exchange)))
		i += copy(dAtA[i:], m.Exchange)
	}
	if len(m.CurrencyPair) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.CurrencyPair)))
		i += copy(dAtA[i:], m.CurrencyPair)
	}
	if m.ExchangeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.ExchangeId))
	}
	if m.CurrencyPairId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.CurrencyPairId))
	}
	if m.MarketId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.MarketId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PriceStr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.PriceStr)))
		i += copy(dAtA[i:], m.PriceStr)
	}
	if len(m.AmountStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.AmountStr)))
		i += copy(dAtA[i:], m.AmountStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.PriceStr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.PriceStr)))
		i += copy(dAtA[i:], m.PriceStr)
	}
	if len(m.AmountStr) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.AmountStr)))
		i += copy(dAtA[i:], m.AmountStr)
	}
	if m.TimestampNano != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.TimestampNano))
	}
	if len(m.ExternalId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.ExternalId)))
		i += copy(dAtA[i:], m.ExternalId)
	}
	if m.OrderSide != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.OrderSide))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MarketUpdateMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketUpdateMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		nn1, err := m.Update.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.Market != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Market.Size()))
		n2, err := m.Market.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MarketUpdateMessage_OrderBookUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OrderBookUpdate != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.OrderBookUpdate.Size()))
		n3, err := m.OrderBookUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *MarketUpdateMessage_OrderBookDeltaUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OrderBookDeltaUpdate != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.OrderBookDeltaUpdate.Size()))
		n4, err := m.OrderBookDeltaUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *MarketUpdateMessage_TradesUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TradesUpdate != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.TradesUpdate.Size()))
		n5, err := m.TradesUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *MarketUpdateMessage_IntervalsUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IntervalsUpdate != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.IntervalsUpdate.Size()))
		n6, err := m.IntervalsUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *MarketUpdateMessage_SummaryUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SummaryUpdate != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.SummaryUpdate.Size()))
		n7, err := m.SummaryUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *MarketUpdateMessage_SparklineUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SparklineUpdate != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.SparklineUpdate.Size()))
		n8, err := m.SparklineUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *MarketUpdateMessage_OrderBookSpreadUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OrderBookSpreadUpdate != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.OrderBookSpreadUpdate.Size()))
		n9, err := m.OrderBookSpreadUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *MarketUpdateMessage_OrderBookLiquidityUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OrderBookLiquidityUpdate != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.OrderBookLiquidityUpdate.Size()))
		n10, err := m.OrderBookLiquidityUpdate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *OrderBookUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bids) > 0 {
		for _, msg := range m.Bids {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Asks) > 0 {
		for _, msg := range m.Asks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AggregationModulusStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.AggregationModulusStr)))
		i += copy(dAtA[i:], m.AggregationModulusStr)
	}
	if m.SeqNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.SeqNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookDeltaUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookDeltaUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bids != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bids.Size()))
		n11, err := m.Bids.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Asks != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Asks.Size()))
		n12, err := m.Asks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.AggregationModulusStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.AggregationModulusStr)))
		i += copy(dAtA[i:], m.AggregationModulusStr)
	}
	if m.SeqNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.SeqNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, msg := range m.Set {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Delta) > 0 {
		for _, msg := range m.Delta {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RemoveStr) > 0 {
		for _, s := range m.RemoveStr {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookSpreadUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookSpreadUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Timestamp))
	}
	if m.Bid != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bid.Size()))
		n13, err := m.Bid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Ask != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Ask.Size()))
		n14, err := m.Ask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookLiquidityUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookLiquidityUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Timestamp))
	}
	if m.Bid != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bid.Size()))
		n15, err := m.Bid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Ask != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Ask.Size()))
		n16, err := m.Ask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TotalBase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.TotalBase)))
		i += copy(dAtA[i:], m.TotalBase)
	}
	if len(m.TotalQuote) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.TotalQuote)))
		i += copy(dAtA[i:], m.TotalQuote)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bip25 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip25.Size()))
		n17, err := m.Bip25.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Bip50 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip50.Size()))
		n18, err := m.Bip50.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Bip75 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip75.Size()))
		n19, err := m.Bip75.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Bip100 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip100.Size()))
		n20, err := m.Bip100.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Bip150 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip150.Size()))
		n21, err := m.Bip150.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Bip200 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip200.Size()))
		n22, err := m.Bip200.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Bip250 != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip250.Size()))
		n23, err := m.Bip250.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Bip300 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip300.Size()))
		n24, err := m.Bip300.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Bip400 != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip400.Size()))
		n25, err := m.Bip400.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Bip500 != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Bip500.Size()))
		n26, err := m.Bip500.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TradesUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradesUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for _, msg := range m.Trades {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Interval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interval) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Closetime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Closetime))
	}
	if m.Ohlc != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Ohlc.Size()))
		n27, err := m.Ohlc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Period != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Period))
	}
	if len(m.VolumeBaseStr) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.VolumeBaseStr)))
		i += copy(dAtA[i:], m.VolumeBaseStr)
	}
	if len(m.VolumeQuoteStr) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.VolumeQuoteStr)))
		i += copy(dAtA[i:], m.VolumeQuoteStr)
	}
	if len(m.PeriodName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.PeriodName)))
		i += copy(dAtA[i:], m.PeriodName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Interval_OHLC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interval_OHLC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpenStr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.OpenStr)))
		i += copy(dAtA[i:], m.OpenStr)
	}
	if len(m.HighStr) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.HighStr)))
		i += copy(dAtA[i:], m.HighStr)
	}
	if len(m.LowStr) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.LowStr)))
		i += copy(dAtA[i:], m.LowStr)
	}
	if len(m.CloseStr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.CloseStr)))
		i += copy(dAtA[i:], m.CloseStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IntervalsUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalsUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Intervals) > 0 {
		for _, msg := range m.Intervals {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMarket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SummaryUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SummaryUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTrades != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.NumTrades))
	}
	if len(m.LastStr) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.LastStr)))
		i += copy(dAtA[i:], m.LastStr)
	}
	if len(m.HighStr) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.HighStr)))
		i += copy(dAtA[i:], m.HighStr)
	}
	if len(m.LowStr) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.LowStr)))
		i += copy(dAtA[i:], m.LowStr)
	}
	if len(m.VolumeBaseStr) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.VolumeBaseStr)))
		i += copy(dAtA[i:], m.VolumeBaseStr)
	}
	if len(m.VolumeQuoteStr) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.VolumeQuoteStr)))
		i += copy(dAtA[i:], m.VolumeQuoteStr)
	}
	if len(m.ChangeAbsoluteStr) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.ChangeAbsoluteStr)))
		i += copy(dAtA[i:], m.ChangeAbsoluteStr)
	}
	if len(m.ChangePercentStr) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.ChangePercentStr)))
		i += copy(dAtA[i:], m.ChangePercentStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SparklineUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparklineUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMarket(dAtA, i, uint64(m.Time))
	}
	if len(m.PriceStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMarket(dAtA, i, uint64(len(m.PriceStr)))
		i += copy(dAtA[i:], m.PriceStr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMarket(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Market) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exchange)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.CurrencyPair)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.ExchangeId != 0 {
		n += 1 + sovMarket(uint64(m.ExchangeId))
	}
	if m.CurrencyPairId != 0 {
		n += 1 + sovMarket(uint64(m.CurrencyPairId))
	}
	if m.MarketId != 0 {
		n += 1 + sovMarket(uint64(m.MarketId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PriceStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.AmountStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovMarket(uint64(m.Timestamp))
	}
	l = len(m.PriceStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.AmountStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.TimestampNano != 0 {
		n += 1 + sovMarket(uint64(m.TimestampNano))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.OrderSide != 0 {
		n += 1 + sovMarket(uint64(m.OrderSide))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarketUpdateMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		n += m.Update.Size()
	}
	if m.Market != nil {
		l = m.Market.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarketUpdateMessage_OrderBookUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderBookUpdate != nil {
		l = m.OrderBookUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_OrderBookDeltaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderBookDeltaUpdate != nil {
		l = m.OrderBookDeltaUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_TradesUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TradesUpdate != nil {
		l = m.TradesUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_IntervalsUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntervalsUpdate != nil {
		l = m.IntervalsUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_SummaryUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SummaryUpdate != nil {
		l = m.SummaryUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_SparklineUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SparklineUpdate != nil {
		l = m.SparklineUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_OrderBookSpreadUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderBookSpreadUpdate != nil {
		l = m.OrderBookSpreadUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *MarketUpdateMessage_OrderBookLiquidityUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderBookLiquidityUpdate != nil {
		l = m.OrderBookLiquidityUpdate.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	return n
}
func (m *OrderBookUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bids) > 0 {
		for _, e := range m.Bids {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.Asks) > 0 {
		for _, e := range m.Asks {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	l = len(m.AggregationModulusStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovMarket(uint64(m.SeqNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookDeltaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bids != nil {
		l = m.Bids.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Asks != nil {
		l = m.Asks.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.AggregationModulusStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovMarket(uint64(m.SeqNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookDeltaUpdate_OrderDeltas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.Delta) > 0 {
		for _, e := range m.Delta {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if len(m.RemoveStr) > 0 {
		for _, s := range m.RemoveStr {
			l = len(s)
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookSpreadUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovMarket(uint64(m.Timestamp))
	}
	if m.Bid != nil {
		l = m.Bid.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Ask != nil {
		l = m.Ask.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookLiquidityUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovMarket(uint64(m.Timestamp))
	}
	if m.Bid != nil {
		l = m.Bid.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Ask != nil {
		l = m.Ask.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TotalBase)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.TotalQuote)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bip25 != nil {
		l = m.Bip25.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip50 != nil {
		l = m.Bip50.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip75 != nil {
		l = m.Bip75.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip100 != nil {
		l = m.Bip100.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip150 != nil {
		l = m.Bip150.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip200 != nil {
		l = m.Bip200.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip250 != nil {
		l = m.Bip250.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip300 != nil {
		l = m.Bip300.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip400 != nil {
		l = m.Bip400.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Bip500 != nil {
		l = m.Bip500.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TradesUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Trades) > 0 {
		for _, e := range m.Trades {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Interval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Closetime != 0 {
		n += 1 + sovMarket(uint64(m.Closetime))
	}
	if m.Ohlc != nil {
		l = m.Ohlc.Size()
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.Period != 0 {
		n += 1 + sovMarket(uint64(m.Period))
	}
	l = len(m.VolumeBaseStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.VolumeQuoteStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.PeriodName)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Interval_OHLC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OpenStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.HighStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.LowStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.CloseStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntervalsUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Intervals) > 0 {
		for _, e := range m.Intervals {
			l = e.Size()
			n += 1 + l + sovMarket(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SummaryUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumTrades != 0 {
		n += 1 + sovMarket(uint64(m.NumTrades))
	}
	l = len(m.LastStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.HighStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.LowStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.VolumeBaseStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.VolumeQuoteStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.ChangeAbsoluteStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	l = len(m.ChangePercentStr)
	if l > 0 {
		n += 2 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SparklineUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovMarket(uint64(m.Time))
	}
	l = len(m.PriceStr)
	if l > 0 {
		n += 1 + l + sovMarket(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMarket(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMarket(x uint64) (n int) {
	return sovMarket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Market) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Market: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Market: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyPair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrencyPair = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeId", wireType)
			}
			m.ExchangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExchangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyPairId", wireType)
			}
			m.CurrencyPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyPairId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNano", wireType)
			}
			m.TimestampNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampNano |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSide", wireType)
			}
			m.OrderSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderSide |= (Trade_OrderSide(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketUpdateMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketUpdateMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketUpdateMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderBookUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_OrderBookUpdate{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookDeltaUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderBookDeltaUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_OrderBookDeltaUpdate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradesUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TradesUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_TradesUpdate{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalsUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntervalsUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_IntervalsUpdate{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SummaryUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SummaryUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_SummaryUpdate{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparklineUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SparklineUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_SparklineUpdate{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Market == nil {
				m.Market = &Market{}
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookSpreadUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderBookSpreadUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_OrderBookSpreadUpdate{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBookLiquidityUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderBookLiquidityUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &MarketUpdateMessage_OrderBookLiquidityUpdate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bids = append(m.Bids, &Order{})
			if err := m.Bids[len(m.Bids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asks = append(m.Asks, &Order{})
			if err := m.Asks[len(m.Asks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationModulusStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregationModulusStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookDeltaUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookDeltaUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookDeltaUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bids == nil {
				m.Bids = &OrderBookDeltaUpdate_OrderDeltas{}
			}
			if err := m.Bids.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Asks == nil {
				m.Asks = &OrderBookDeltaUpdate_OrderDeltas{}
			}
			if err := m.Asks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationModulusStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregationModulusStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookDeltaUpdate_OrderDeltas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderDeltas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderDeltas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &Order{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delta = append(m.Delta, &Order{})
			if err := m.Delta[len(m.Delta)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoveStr = append(m.RemoveStr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookSpreadUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookSpreadUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookSpreadUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bid == nil {
				m.Bid = &Order{}
			}
			if err := m.Bid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ask == nil {
				m.Ask = &Order{}
			}
			if err := m.Ask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookLiquidityUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookLiquidityUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookLiquidityUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bid == nil {
				m.Bid = &OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide{}
			}
			if err := m.Bid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ask == nil {
				m.Ask = &OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide{}
			}
			if err := m.Ask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquiditySums) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookLiquiditySums: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookLiquiditySums: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalBase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookLiquidityUpdate_OrderBookLiquidityUpdateSide) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookLiquidityUpdateSide: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookLiquidityUpdateSide: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip25", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip25 == nil {
				m.Bip25 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip25.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip50", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip50 == nil {
				m.Bip50 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip50.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip75", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip75 == nil {
				m.Bip75 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip75.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip100", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip100 == nil {
				m.Bip100 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip100.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip150", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip150 == nil {
				m.Bip150 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip150.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip200", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip200 == nil {
				m.Bip200 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip200.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip250", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip250 == nil {
				m.Bip250 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip250.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip300", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip300 == nil {
				m.Bip300 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip300.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip400", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip400 == nil {
				m.Bip400 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip400.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bip500", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bip500 == nil {
				m.Bip500 = &OrderBookLiquidityUpdate_OrderBookLiquiditySums{}
			}
			if err := m.Bip500.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradesUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradesUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradesUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trades = append(m.Trades, &Trade{})
			if err := m.Trades[len(m.Trades)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Closetime", wireType)
			}
			m.Closetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Closetime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ohlc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ohlc == nil {
				m.Ohlc = &Interval_OHLC{}
			}
			if err := m.Ohlc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeBaseStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeBaseStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeQuoteStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeQuoteStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeriodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interval_OHLC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OHLC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OHLC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloseStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntervalsUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntervalsUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntervalsUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intervals = append(m.Intervals, &Interval{})
			if err := m.Intervals[len(m.Intervals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SummaryUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SummaryUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SummaryUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTrades", wireType)
			}
			m.NumTrades = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTrades |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeBaseStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeBaseStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeQuoteStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeQuoteStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeAbsoluteStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeAbsoluteStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePercentStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangePercentStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparklineUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparklineUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparklineUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMarket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMarket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMarket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMarket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMarket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMarket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMarket
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMarket
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMarket(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMarket = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMarket   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("public/markets/market.proto", fileDescriptor_market_4eb507ded1b31144) }

var fileDescriptor_market_4eb507ded1b31144 = []byte{
	// 1414 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x6e, 0xdb, 0xc6,
	0x16, 0x16, 0xc5, 0x1f, 0x53, 0x47, 0x92, 0xc5, 0x3b, 0x37, 0xc9, 0xe5, 0xd5, 0xcd, 0x15, 0x0c,
	0xa2, 0x09, 0xdc, 0x20, 0x70, 0x18, 0x39, 0x42, 0x76, 0x41, 0xeb, 0xc4, 0x81, 0xad, 0xfa, 0x27,
	0x1d, 0xc5, 0x69, 0x82, 0x16, 0x05, 0x28, 0x71, 0x2a, 0x13, 0xa2, 0x44, 0x85, 0x3f, 0x49, 0xf3,
	0x08, 0x5d, 0x76, 0x57, 0x14, 0x45, 0xd1, 0x65, 0x17, 0x5d, 0xf4, 0x31, 0xba, 0x6c, 0xdf, 0xa0,
	0x48, 0x1e, 0xa1, 0x2f, 0x50, 0xcc, 0x8f, 0x28, 0x52, 0x12, 0x9d, 0xa0, 0xd1, 0x8a, 0x3c, 0x67,
	0xbe, 0xf9, 0xe6, 0xfc, 0x70, 0xe6, 0xcc, 0x21, 0xfc, 0x6f, 0x9a, 0xf4, 0x7d, 0x6f, 0x70, 0x6b,
	0xec, 0x84, 0x23, 0x12, 0x47, 0xe2, 0xb9, 0x33, 0x0d, 0x83, 0x38, 0x40, 0x8d, 0x47, 0xf4, 0xd1,
	0x4f, 0xbe, 0x3a, 0xe6, 0xa3, 0xd6, 0x2f, 0x12, 0x68, 0xfc, 0x1d, 0x35, 0x41, 0x27, 0x5f, 0x0f,
	0xce, 0x9d, 0xc9, 0x90, 0x98, 0xd2, 0x96, 0xb4, 0x5d, 0xc1, 0xa9, 0x8c, 0x2c, 0xa8, 0x0d, 0x92,
	0x30, 0x24, 0x93, 0xc1, 0xab, 0x47, 0x8e, 0x17, 0x9a, 0x65, 0x36, 0x9e, 0xd3, 0xa1, 0x16, 0xc0,
	0x0c, 0x7f, 0xe8, 0x9a, 0xf2, 0x96, 0xb4, 0xad, 0xe0, 0x8c, 0x06, 0x5d, 0x87, 0xcd, 0x2c, 0xfe,
	0xd0, 0x35, 0x15, 0x86, 0x59, 0xd0, 0x52, 0x3b, 0xb8, 0xcd, 0x87, 0xae, 0xa9, 0x32, 0x44, 0x2a,
	0x5b, 0x5f, 0x80, 0x7a, 0x1a, 0xba, 0x24, 0xa4, 0xa0, 0x69, 0xe8, 0x0d, 0x48, 0x2f, 0x0e, 0xd9,
	0x52, 0x15, 0x9c, 0xca, 0xe8, 0x2a, 0x54, 0x9c, 0x71, 0x90, 0x4c, 0x62, 0x3a, 0xa8, 0xb0, 0xc1,
	0xb9, 0xa2, 0xab, 0xe8, 0x92, 0x51, 0xee, 0x2a, 0x7a, 0xd9, 0x90, 0xb1, 0xca, 0xe6, 0x60, 0x8d,
	0x8f, 0x5a, 0xbf, 0xca, 0xa0, 0x3e, 0x0e, 0x1d, 0x97, 0x50, 0x8a, 0xd8, 0x1b, 0x93, 0x28, 0x76,
	0xc6, 0x53, 0xe6, 0xac, 0x8c, 0xe7, 0x8a, 0xdc, 0xe2, 0xfa, 0x45, 0x8b, 0x57, 0x16, 0x16, 0x47,
	0x1f, 0x40, 0x3d, 0xa5, 0x39, 0x71, 0x26, 0x81, 0x09, 0x8c, 0x3b, 0xaf, 0xe4, 0x91, 0x8c, 0x49,
	0x38, 0x71, 0xfc, 0x43, 0xd7, 0xac, 0x32, 0x92, 0x8c, 0x06, 0xdd, 0x83, 0x4a, 0x40, 0xa3, 0xd0,
	0xf3, 0x5c, 0x62, 0xd6, 0xb7, 0xa4, 0xed, 0xcd, 0xf6, 0xd6, 0xce, 0x42, 0x66, 0x77, 0x98, 0x23,
	0x3b, 0xa7, 0x33, 0x1c, 0x9e, 0x4f, 0xb1, 0x76, 0xa1, 0x92, 0xea, 0x51, 0x15, 0x36, 0xce, 0x4e,
	0x3e, 0x39, 0x39, 0xfd, 0xec, 0xc4, 0x28, 0x51, 0x61, 0xef, 0xec, 0x59, 0xef, 0xf0, 0xc1, 0xbe,
	0x21, 0xa1, 0x1a, 0xe8, 0xbd, 0xfd, 0xa3, 0x23, 0x26, 0x95, 0xad, 0x6b, 0xa0, 0x08, 0xbc, 0xbc,
	0x77, 0xf6, 0xcc, 0x28, 0x35, 0xcb, 0x3a, 0x85, 0x28, 0x14, 0x62, 0x48, 0x54, 0x6a, 0x96, 0x4d,
	0x29, 0x0d, 0xaf, 0x6c, 0x28, 0x5d, 0x45, 0x57, 0x0c, 0xb5, 0xab, 0xe8, 0xaa, 0xa1, 0x75, 0x15,
	0x5d, 0x33, 0x36, 0xba, 0x8a, 0xbe, 0x61, 0xe8, 0x5d, 0x45, 0xaf, 0x19, 0xf5, 0x85, 0xe0, 0xe3,
	0x46, 0x1a, 0x83, 0x63, 0xcf, 0xf7, 0xbd, 0x08, 0x97, 0x3d, 0x17, 0x57, 0x19, 0xe6, 0x41, 0x90,
	0xf4, 0x7d, 0x82, 0x6b, 0x1c, 0x29, 0x24, 0x25, 0xa2, 0xae, 0xfc, 0xa5, 0xc2, 0xbf, 0xb9, 0xc7,
	0x67, 0x53, 0xd7, 0x89, 0xc9, 0x31, 0x89, 0x22, 0x67, 0x48, 0xd0, 0x11, 0x34, 0x98, 0xbf, 0x7b,
	0x41, 0x30, 0xe2, 0x23, 0x2c, 0x8d, 0xd5, 0x15, 0x81, 0x3a, 0xcd, 0xe3, 0x0e, 0x4a, 0x78, 0x71,
	0x2a, 0xfa, 0x1c, 0x2e, 0xa5, 0xaa, 0x07, 0xc4, 0x8f, 0x1d, 0x41, 0x29, 0x33, 0xca, 0x6b, 0xc5,
	0x94, 0x19, 0xf0, 0x41, 0x09, 0xaf, 0x24, 0x41, 0xf7, 0xa1, 0x16, 0xd3, 0x5c, 0x45, 0x82, 0x54,
	0x61, 0xa4, 0xff, 0x5f, 0x9d, 0xd0, 0x28, 0x25, 0xcb, 0x4d, 0xa2, 0xfe, 0x7a, 0x93, 0x98, 0x84,
	0x2f, 0x1c, 0x7f, 0xc6, 0xa3, 0x16, 0xf8, 0x7b, 0x98, 0xc7, 0x51, 0x7f, 0x17, 0xa6, 0xa2, 0x87,
	0x50, 0x8f, 0x92, 0xf1, 0xd8, 0x09, 0x5f, 0x09, 0x2e, 0x8d, 0x71, 0xb5, 0x96, 0xb8, 0x7a, 0x59,
	0xd4, 0x41, 0x09, 0xe7, 0xa7, 0x51, 0xab, 0xa2, 0xa9, 0x13, 0x8e, 0x7c, 0x6f, 0x42, 0x04, 0xd3,
	0x46, 0x81, 0x55, 0xbd, 0x3c, 0x8e, 0x5a, 0xb5, 0x30, 0x15, 0xdd, 0x02, 0x8d, 0x1f, 0x04, 0x6c,
	0x5f, 0x55, 0xdb, 0xff, 0x59, 0x22, 0xe1, 0x4f, 0x2c, 0x60, 0xe8, 0x4b, 0xb8, 0x9c, 0x46, 0xbc,
	0x37, 0x0d, 0x89, 0xe3, 0x0a, 0x23, 0xaa, 0x6c, 0xfe, 0xf5, 0xe2, 0xbc, 0x65, 0xd1, 0x07, 0x25,
	0xbc, 0x9a, 0x06, 0x0d, 0xc1, 0x4c, 0x07, 0x8e, 0xbc, 0xe7, 0x89, 0xe7, 0x7a, 0xf1, 0x2c, 0x62,
	0x35, 0xb6, 0xc4, 0x87, 0xc5, 0x4b, 0x2c, 0x4c, 0x38, 0x28, 0xe1, 0x42, 0xb2, 0x3d, 0x1d, 0x34,
	0xfe, 0xd6, 0x55, 0x74, 0xdd, 0xa8, 0x58, 0x7f, 0x48, 0xd0, 0x58, 0xf8, 0x6c, 0xd1, 0x0d, 0x50,
	0xfa, 0x9e, 0x1b, 0x99, 0xd2, 0x96, 0xbc, 0x5d, 0x6d, 0x5f, 0x59, 0xbd, 0x30, 0x66, 0x18, 0x8a,
	0x75, 0xa2, 0x51, 0x64, 0x96, 0x2f, 0xc6, 0x52, 0x0c, 0xba, 0x03, 0x97, 0x9d, 0xe1, 0x30, 0x24,
	0x43, 0x27, 0xf6, 0x82, 0xc9, 0x71, 0xe0, 0x26, 0x7e, 0x12, 0xcd, 0x4f, 0xd6, 0xd5, 0x83, 0xe8,
	0x0a, 0x68, 0x11, 0x79, 0x7e, 0x92, 0x8c, 0xd9, 0x67, 0xa8, 0x62, 0x21, 0xf1, 0x83, 0x01, 0xa3,
	0xe5, 0x49, 0xd6, 0x4f, 0x32, 0x5c, 0x5a, 0xb5, 0x6f, 0xd0, 0x7e, 0xea, 0x18, 0x8d, 0xe8, 0xed,
	0x77, 0xda, 0x6c, 0x5c, 0xc9, 0x14, 0x91, 0xf0, 0x79, 0x3f, 0xf5, 0xf9, 0x9f, 0xd2, 0xac, 0x3f,
	0x1c, 0xcd, 0x6f, 0x25, 0xa8, 0x66, 0xd6, 0x40, 0xdb, 0x20, 0x47, 0x24, 0x7e, 0x4b, 0x0e, 0x29,
	0x04, 0xdd, 0x04, 0xd5, 0xa5, 0x73, 0xde, 0x92, 0x43, 0x0e, 0xa2, 0x55, 0x29, 0x24, 0xe3, 0xe0,
	0x05, 0xe1, 0x96, 0xca, 0xb4, 0x2a, 0xa5, 0x0a, 0x91, 0x14, 0x8d, 0x2b, 0x2e, 0x48, 0xd1, 0x37,
	0x12, 0x5c, 0x5e, 0xb9, 0x45, 0xf2, 0xf5, 0x52, 0x5a, 0xac, 0x97, 0xdb, 0x20, 0xf7, 0x3d, 0x57,
	0x44, 0xbe, 0xd0, 0xab, 0xbe, 0xe7, 0x52, 0xa4, 0x13, 0x8d, 0xc4, 0xb9, 0x5a, 0x88, 0x74, 0xa2,
	0x91, 0xf5, 0xa6, 0x02, 0x66, 0xd1, 0x5e, 0x7a, 0x8b, 0x39, 0x4f, 0xb3, 0xe6, 0x3c, 0x7c, 0xe7,
	0x1d, 0x5a, 0x38, 0xc0, 0xca, 0x2b, 0x33, 0xff, 0x69, 0xd6, 0xfc, 0xb5, 0x31, 0x3b, 0xd1, 0xa8,
	0xf9, 0x04, 0xae, 0x2c, 0x83, 0x7a, 0xc9, 0x38, 0x62, 0xbe, 0x06, 0xb1, 0xe3, 0xef, 0x39, 0xd1,
	0xec, 0xde, 0x36, 0x57, 0xd0, 0xab, 0x04, 0x13, 0x3e, 0x4d, 0x02, 0x51, 0x02, 0x2b, 0x38, 0xa3,
	0x69, 0xfe, 0xb0, 0x01, 0x57, 0x2f, 0x5a, 0x1d, 0x3d, 0x01, 0xb5, 0xef, 0x4d, 0xdb, 0x1d, 0xb1,
	0xfd, 0x3e, 0x7a, 0x1f, 0xa7, 0xa8, 0xbd, 0x98, 0xd3, 0x09, 0xde, 0x8e, 0x2d, 0xd2, 0xb0, 0x1e,
	0xde, 0x8e, 0x2d, 0x78, 0xef, 0x76, 0x44, 0x12, 0xd6, 0xc3, 0x7b, 0xb7, 0x83, 0x9e, 0x82, 0xd6,
	0xf7, 0xa6, 0xb7, 0x6d, 0x5b, 0xd4, 0xe7, 0xf7, 0x27, 0x16, 0x7c, 0x33, 0xe6, 0x8e, 0x2d, 0x2a,
	0xf6, 0x9a, 0x98, 0x3b, 0x33, 0xe6, 0xb6, 0x6d, 0x8b, 0xfa, 0xbd, 0x1e, 0xe6, 0x76, 0x6a, 0x73,
	0xbb, 0x63, 0x8b, 0x7a, 0xbe, 0x26, 0xe6, 0xd4, 0xe6, 0x5d, 0xdb, 0x66, 0x37, 0xeb, 0x75, 0x31,
	0xef, 0xa6, 0x36, 0xdf, 0xb1, 0x6d, 0x71, 0x7d, 0x58, 0x0f, 0xf3, 0x9d, 0x94, 0xb9, 0x63, 0xdb,
	0xec, 0x3a, 0xbf, 0x2e, 0xe6, 0x8e, 0x6d, 0x5b, 0xf7, 0xa0, 0x96, 0xbd, 0xf6, 0xa1, 0x1d, 0xd0,
	0xf8, 0xb5, 0xaf, 0xb0, 0x44, 0x30, 0x38, 0x16, 0x28, 0xeb, 0x67, 0x19, 0xf4, 0xd9, 0x7d, 0x8f,
	0x9e, 0x14, 0x03, 0x3f, 0x88, 0x08, 0x3d, 0x09, 0x67, 0xa7, 0x62, 0xaa, 0x40, 0x6d, 0x50, 0x82,
	0x73, 0x7f, 0x20, 0xf6, 0x63, 0xab, 0xf0, 0xda, 0xb8, 0x73, 0x7a, 0x70, 0x74, 0x1f, 0x33, 0x2c,
	0x2d, 0x6b, 0x53, 0x12, 0x7a, 0x01, 0x6f, 0xe5, 0x54, 0x2c, 0x24, 0xda, 0xe6, 0xbc, 0x08, 0xfc,
	0x64, 0x4c, 0xe8, 0x19, 0x44, 0x4b, 0x8e, 0xc6, 0x0e, 0x9e, 0xbc, 0x92, 0x36, 0x84, 0x5c, 0xc1,
	0x8e, 0x22, 0x0a, 0xdb, 0x60, 0xb0, 0x05, 0x2d, 0x3d, 0xc3, 0x38, 0xef, 0x89, 0x33, 0x26, 0xa2,
	0xa7, 0xca, 0x68, 0x9a, 0x3f, 0x4a, 0xa0, 0x50, 0xa3, 0x90, 0x09, 0x1b, 0xc1, 0x94, 0x4c, 0x28,
	0x93, 0xca, 0x50, 0x33, 0x91, 0x8e, 0x9c, 0x7b, 0xc3, 0xf3, 0xb9, 0x29, 0x33, 0x91, 0xba, 0xe0,
	0x07, 0x2f, 0xe7, 0x8b, 0x0b, 0x89, 0xf6, 0x78, 0x2c, 0x36, 0x99, 0x1e, 0x6f, 0x26, 0x67, 0x5b,
	0xc8, 0x6c, 0xa7, 0x83, 0x15, 0xba, 0x1c, 0x56, 0x28, 0x35, 0x96, 0xfd, 0xe0, 0x25, 0x56, 0xd9,
	0x94, 0x14, 0xa3, 0x1a, 0x1a, 0x86, 0x79, 0x0c, 0x70, 0x35, 0xe3, 0xa8, 0xd5, 0x85, 0xc6, 0xc2,
	0xcd, 0x1c, 0xdd, 0x85, 0x4a, 0x7a, 0x33, 0x17, 0x09, 0xff, 0x6f, 0x61, 0x5e, 0xf0, 0x1c, 0x6b,
	0x7d, 0x2f, 0x43, 0x3d, 0x77, 0x35, 0xa7, 0xb9, 0x9f, 0x24, 0x63, 0xfe, 0x2d, 0x31, 0x7f, 0x54,
	0x3c, 0x57, 0xd0, 0xf0, 0xf8, 0x4e, 0xc4, 0x5a, 0x56, 0xe0, 0xe1, 0x11, 0x62, 0x36, 0x70, 0xd5,
	0xa2, 0xc0, 0xd5, 0x72, 0x81, 0x5b, 0xca, 0x7d, 0xfd, 0xdd, 0x72, 0xbf, 0xb9, 0x32, 0xf7, 0x37,
	0xe1, 0x5f, 0xfc, 0x07, 0xc2, 0xc7, 0xfd, 0x28, 0xf0, 0x13, 0x0e, 0x6d, 0x30, 0xe8, 0xf2, 0x00,
	0xba, 0x01, 0x06, 0x57, 0x3e, 0x22, 0xe1, 0x80, 0xf0, 0x1e, 0xdc, 0x60, 0xe0, 0x25, 0x7d, 0x51,
	0x12, 0x57, 0xb6, 0xab, 0x15, 0x03, 0xb0, 0x42, 0x43, 0x92, 0x4d, 0x6e, 0x51, 0x26, 0xf1, 0x66,
	0xde, 0x30, 0x5c, 0xcf, 0xad, 0x6d, 0x3d, 0x86, 0xc6, 0x42, 0xb3, 0x83, 0x10, 0x28, 0x6c, 0x53,
	0xf2, 0x3f, 0x0d, 0xec, 0x3d, 0xf7, 0x93, 0x41, 0xc9, 0xff, 0x64, 0xc8, 0x36, 0xd9, 0xa2, 0x8d,
	0xde, 0x33, 0x7e, 0x7b, 0xdd, 0x92, 0x7e, 0x7f, 0xdd, 0x92, 0xfe, 0x7c, 0xdd, 0x92, 0xbe, 0x7b,
	0xd3, 0x2a, 0xf5, 0x35, 0xf6, 0xcb, 0x67, 0xf7, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x31, 0xa1,
	0x14, 0xc8, 0x11, 0x12, 0x00, 0x00,
}
